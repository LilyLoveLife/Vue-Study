

1. 两种用法 https://cn.vuejs.org/v2/api/#watch
1.1 watch是一个对象，对象的一个个属性是函数
watch: {
  d () {}
}
1.2 watch是一个对象，属性还是对象，对象是handle和附加属性
watch: {
  d: {
      handler: 'someMethod',
      immediate: true // 初始化立刻执行一次
      deep: true, // 深度监听
  },
}

2. 实现原理：参看vue源码initWatch => Vue.prototype.$watch => new Watcher
function initWatch(vm, watch) {
  for (let key in watch) {
    vm.$watch(key, watch[key].handle, watch[key])
  }
}

Vue.prototype.$watch = function (expOrFn, cb, options) {
  const vm = this
  const watcher = new Watcher(vm, expOrFn, cb, options)
  if (watcher.immediate) { // 初始化便执行一次
    vm.call(cb, watcher.value)
  }
  return function unwatch() { // 返回一个函数，用于解除监听
    watcher.teardown()
  }
}

class Watcher {
  constructor (vm, exprOrFn, cb, options, isRenderWatcher) {
    this.deep = !!options.deep
    this.value = this.get()
    this.getter = expOrFn // 监听的数据
  }
  get () {
    try {
      value = this.getter.call(vm, vm) // 通过expOrFn获取value，监听的数据。相当于触发数据的get，从而将访问该数据的表达式加入该数据的依赖集合deps中
    }finally () {
      if (this.deep) {
        traverse(value)
      }
    }
  }
}

